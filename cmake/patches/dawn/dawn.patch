diff --git a/src/cmake/DawnCompilerPlatformFlags.cmake b/src/cmake/DawnCompilerPlatformFlags.cmake
index 50638e2456..efa42711e6 100644
--- a/src/cmake/DawnCompilerPlatformFlags.cmake
+++ b/src/cmake/DawnCompilerPlatformFlags.cmake
@@ -63,7 +63,3 @@ endif ()
 if (MSVC AND NOT COMPILER_IS_CLANG_CL)
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /MP")
 endif ()
-
-if (TARGET_MACOS)
-    set(CMAKE_OSX_DEPLOYMENT_TARGET "11.0" CACHE STRING "Minimum macOS version" FORCE)
-endif ()
\ No newline at end of file
diff --git a/src/emdawnwebgpu/CMakeLists.txt b/src/emdawnwebgpu/CMakeLists.txt
index 6e8ae37593..633af91eef 100644
--- a/src/emdawnwebgpu/CMakeLists.txt
+++ b/src/emdawnwebgpu/CMakeLists.txt
@@ -77,9 +77,17 @@ if (${DAWN_ENABLE_EMSCRIPTEN})
                 "${arg_UNPARSED_ARGUMENTS}")
         endif()
 
+        # since Emscripten 4.0.3, file gen_struct_info.py is moved to outside of directory maint.
+        if (EXISTS "${DAWN_EMSCRIPTEN_TOOLCHAIN}/tools/gen_struct_info.py")
+            set(EM_GEN_STRUCT_INFO_SCRIPT "${DAWN_EMSCRIPTEN_TOOLCHAIN}/tools/gen_struct_info.py")
+        elseif (EXISTS "${DAWN_EMSCRIPTEN_TOOLCHAIN}/tools/maint/gen_struct_info.py")
+            set(EM_GEN_STRUCT_INFO_SCRIPT "${DAWN_EMSCRIPTEN_TOOLCHAIN}/tools/maint/gen_struct_info.py")
+        else()
+            message(FATAL_ERROR "Dawn: Failed to locate file gen_struct_info.py from Emscripten.")
+        endif()
         set(ARGS
             ${Python3_EXECUTABLE}
-            "${DAWN_EMSCRIPTEN_TOOLCHAIN}/tools/maint/gen_struct_info.py"
+            "${EM_GEN_STRUCT_INFO_SCRIPT}"
             -q
             "${EM_BUILD_GEN_DIR}/struct_info_webgpu.json"
             "-I=${EM_BUILD_GEN_DIR}/include"
diff --git a/src/emdawnwebgpu/README.md b/src/emdawnwebgpu/README.md
index efd6491cd6..8ebc5d28b6 100644
--- a/src/emdawnwebgpu/README.md
+++ b/src/emdawnwebgpu/README.md
@@ -56,7 +56,7 @@ Set up the build directory using emcmake
 mkdir out/cmake-wasm
 cd out/cmake-wasm
 
-# Make sure the path is to the source checkout of Emscripten, not emsdk's release.
+# If using Emscripten v4.0.2 or lower, make sure the path is to the source checkout of Emscripten, not emsdk's release.
 emcmake cmake -GNinja -DDAWN_EMSCRIPTEN_TOOLCHAIN="path/to/emscripten" ../..
 
 ninja
diff --git a/third_party/emdawnwebgpu/library_webgpu.js b/third_party/emdawnwebgpu/library_webgpu.js
index f8ef77d5c4..57573ef51a 100644
--- a/third_party/emdawnwebgpu/library_webgpu.js
+++ b/third_party/emdawnwebgpu/library_webgpu.js
@@ -66,7 +66,7 @@
         importJs${object}__deps: ['emwgpuCreate${object}'],
         importJs${object}: (obj, parentPtr = 0) => {
           var ptr = _emwgpuCreate${object}(parentPtr);
-          WebGPU.Internals.jsObjects[ptr] = obj;
+          WebGPU.Internals.jsObjects.set(ptr, obj);
           return ptr;
         },
       `
@@ -94,14 +94,14 @@ var LibraryWebGPU = {
     Internals: {
       // Object management is consolidated into a single table that doesn't
       // care about object type, and is keyed on the pointer address.
-      jsObjects: [],
+      jsObjects: new Map(),
       jsObjectInsert: (ptr, jsObject) => {
-        WebGPU.Internals.jsObjects[ptr] = jsObject;
+        WebGPU.Internals.jsObjects.set(ptr, jsObject);
       },
 
       // Buffer unmapping callbacks are stored in a separate table to keep
       // the jsObject table simple.
-      bufferOnUnmaps: [],
+      bufferOnUnmaps: new Map(),
 
       // Future to promise management. Note that all FutureIDs (uint64_t) are
       // passed either as a low and high value or by pointer because they need
@@ -109,11 +109,11 @@ var LibraryWebGPU = {
       // unable to pass a value to a C++ function as a uint64_t. This might be
       // possible with -sWASM_BIGINT, but I was unable to get that to work
       // properly at the time of writing.
-      futures: [],
+      futures: new Map(),
       futureInsert: (futureId, promise) => {
 #if ASYNCIFY
-        WebGPU.Internals.futures[futureId] =
-          new Promise((resolve) => promise.finally(() => resolve(futureId)));
+        WebGPU.Internals.futures.set(futureId,
+                                     new Promise((resolve) => promise.finally(() => resolve(futureId))));
 #endif
       },
     },
@@ -131,9 +131,9 @@ var LibraryWebGPU = {
     getJsObject: (ptr) => {
       if (!ptr) return undefined;
 #if ASSERTIONS
-      assert(ptr in WebGPU.Internals.jsObjects);
+      assert(WebGPU.Internals.jsObjects.has(ptr));
 #endif
-      return WebGPU.Internals.jsObjects[ptr];
+      return WebGPU.Internals.jsObjects.get(ptr);
     },
     {{{ gpu.makeImportJsObject('Adapter') }}}
     {{{ gpu.makeImportJsObject('BindGroup') }}}
@@ -593,7 +593,7 @@ var LibraryWebGPU = {
 
   emwgpuDelete__sig: 'vp',
   emwgpuDelete: (ptr) => {
-    delete WebGPU.Internals.jsObjects[ptr];
+    WebGPU.Internals.jsObjects.delete(ptr);
   },
 
   emwgpuSetLabel__deps: ['$UTF8ToString'],
@@ -621,14 +621,15 @@ var LibraryWebGPU = {
     for (var i = 0; i < futureCount; ++i) {
       // If any of the FutureIDs are not tracked, it means it must be done.
       var futureId = {{{ gpu.makeGetU64('(futurePtr + i * 8)', 0) }}};
-      if (!(futureId in WebGPU.Internals.futures)) {
+      var promise = WebGPU.Internals.futures.get(futureId);
+      if (promise === undefined) {
         return futureId;
       }
-      promises[i] = WebGPU.Internals.futures[futureId];
+      promises[i] = promise;
     }
 
     const firstResolvedFuture = await Promise.race(promises);
-    delete WebGPU.Internals.futures[firstResolvedFuture];
+    WebGPU.Internals.futures.delete(firstResolvedFuture);
     return firstResolvedFuture;
   }),
 #else
@@ -820,6 +821,61 @@ var LibraryWebGPU = {
     {{{ runtimeKeepalivePush() }}}
     WebGPU.Internals.futureInsert(futureId, adapter.requestDevice(desc).then((device) => {
       {{{ runtimeKeepalivePop() }}}
+
+      if (globalThis["WEBGPU_STAT"]) {
+        // a set that caches all active buffers
+        const buffers = WebGPU.Internals.buffers ??= new Set();
+        // key is buffer usage, value is total size of buffers with that usage
+        const buffersTotalSize = WebGPU.Internals.buffersTotalSize ??= new Map();
+
+        WebGPU.Internals.buffersCreated ??= 0;
+        WebGPU.Internals.buffersDestroyed ??= 0;
+        WebGPU.Internals.buffersUploads ??= 0;
+        WebGPU.Internals.buffersExternalUploads ??= 0;
+        WebGPU.Internals.buffersDownloads ??= 0;
+        WebGPU.Internals.buffersExternalDownloads ??= 0;
+
+        // create a proxy so that we can monitor buffer usages
+        device = new Proxy(device, {
+          // when call device.createBuffer(), the returned buffer should be added into buffers
+          get: (target, prop, _receiver) => {
+            if (prop === 'createBuffer') {
+              return (desc) => {
+                const buffer = target.createBuffer(desc);
+                const originalDestroy = buffer.destroy.bind(buffer);
+                buffer.destroy = () => {
+                  const previousTotal = buffersTotalSize.get(buffer.usage);
+                  buffersTotalSize.set(buffer.usage, previousTotal - buffer.size);
+                  buffers.delete(buffer);
+                  WebGPU.Internals.buffersDestroyed++;
+                  originalDestroy();
+                };
+
+                if (buffer.usage === (GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC)) {
+                  WebGPU.Internals.buffersUploads++;
+                }
+                if (buffer.usage === (GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ)) {
+                  WebGPU.Internals.buffersDownloads++;
+                }
+
+                buffers.add(buffer);
+                const previousTotal = buffersTotalSize.get(buffer.usage) ?? 0;
+                buffersTotalSize.set(buffer.usage, previousTotal + buffer.size);
+                WebGPU.Internals.buffersCreated++;
+                return buffer;
+              };
+            }
+            const propertyValue = Reflect.get(target, prop);
+            if (typeof propertyValue === 'function') {
+              return propertyValue.bind(target);
+            } else {
+              return propertyValue;
+            }
+          },
+          set: (target, prop, value, _receiver) => Reflect.set(target, prop, value),
+        });
+      }
+
       WebGPU.Internals.jsObjectInsert(queuePtr, device.queue);
       WebGPU.Internals.jsObjectInsert(devicePtr, device);
 
@@ -888,12 +944,12 @@ var LibraryWebGPU = {
   emwgpuBufferDestroy__sig: 'vp',
   emwgpuBufferDestroy: (bufferPtr) => {
     var buffer = WebGPU.getJsObject(bufferPtr);
-    var onUnmap = WebGPU.Internals.bufferOnUnmaps[bufferPtr];
+    var onUnmap = WebGPU.Internals.bufferOnUnmaps.get(bufferPtr);
     if (onUnmap) {
       for (var i = 0; i < onUnmap.length; ++i) {
         onUnmap[i]();
       }
-      delete WebGPU.Internals.bufferOnUnmaps[bufferPtr];
+      WebGPU.Internals.bufferOnUnmaps.delete(bufferPtr);
     }
 
     buffer.destroy();
@@ -922,7 +978,7 @@ var LibraryWebGPU = {
     }
     var data = _memalign(16, mapped.byteLength);
     HEAPU8.set(new Uint8Array(mapped), data);
-    WebGPU.Internals.bufferOnUnmaps[bufferPtr].push(() => _free(data));
+    WebGPU.Internals.bufferOnUnmaps.get(bufferPtr).push(() => _free(data));
     return data;
   },
 
@@ -950,7 +1006,7 @@ var LibraryWebGPU = {
 
     var data = _memalign(16, mapped.byteLength);
     HEAPU8.fill(0, data, mapped.byteLength);
-    WebGPU.Internals.bufferOnUnmaps[bufferPtr].push(() => {
+    WebGPU.Internals.bufferOnUnmaps.get(bufferPtr).push(() => {
       new Uint8Array(mapped).set(HEAPU8.subarray(data, data + mapped.byteLength));
       _free(data);
     });
@@ -974,7 +1030,7 @@ var LibraryWebGPU = {
   emwgpuBufferMapAsync__sig: 'vpjjpp',
   emwgpuBufferMapAsync: (bufferPtr, futureId, mode, offset, size) => {
     var buffer = WebGPU.getJsObject(bufferPtr);
-    WebGPU.Internals.bufferOnUnmaps[bufferPtr] = [];
+    WebGPU.Internals.bufferOnUnmaps.set(bufferPtr, []);
 
     {{{ gpu.convertSentinelToUndefined('size', true) }}}
 
@@ -993,7 +1049,7 @@ var LibraryWebGPU = {
         0;
       {{{ gpu.makeCheck('status') }}}
       _emwgpuOnMapAsyncCompleted(futureId, status, {{{ gpu.passAsPointer('messagePtr') }}});
-      delete WebGPU.Internals.bufferOnUnmaps[bufferPtr];
+      WebGPU.Internals.bufferOnUnmaps.delete(bufferPtr);
     }));
   },
 
@@ -1001,7 +1057,7 @@ var LibraryWebGPU = {
   emwgpuBufferUnmap: (bufferPtr) => {
     var buffer = WebGPU.getJsObject(bufferPtr);
 
-    var onUnmap = WebGPU.Internals.bufferOnUnmaps[bufferPtr];
+    var onUnmap = WebGPU.Internals.bufferOnUnmaps.get(bufferPtr);
     if (!onUnmap) {
       // Already unmapped
       return;
@@ -1010,7 +1066,7 @@ var LibraryWebGPU = {
     for (var i = 0; i < onUnmap.length; ++i) {
       onUnmap[i]();
     }
-    delete WebGPU.Internals.bufferOnUnmaps[bufferPtr]
+    WebGPU.Internals.bufferOnUnmaps.delete(bufferPtr);
 
     buffer.unmap();
   },
@@ -1487,7 +1543,7 @@ var LibraryWebGPU = {
     var device = WebGPU.getJsObject(devicePtr);
     WebGPU.Internals.jsObjectInsert(bufferPtr, device.createBuffer(desc));
     if (mappedAtCreation) {
-      WebGPU.Internals.bufferOnUnmaps[bufferPtr] = [];
+      WebGPU.Internals.bufferOnUnmaps.set(bufferPtr, []);
     }
   },
 
diff --git a/third_party/emdawnwebgpu/webgpu.cpp b/third_party/emdawnwebgpu/webgpu.cpp
index f1c5a7d50e..16f2495712 100644
--- a/third_party/emdawnwebgpu/webgpu.cpp
+++ b/third_party/emdawnwebgpu/webgpu.cpp
@@ -131,7 +131,6 @@ class RefCounted : NonMovable {
   bool Release() {
     if (mRefCount.fetch_sub(1u, std::memory_order_release) == 1u) {
       std::atomic_thread_fence(std::memory_order_acquire);
-      emwgpuDelete(this);
       return true;
     }
     return false;
@@ -234,6 +233,7 @@ class Ref {
   static void Release(T value) {
     if (value != nullptr && value->RefCounted::Release()) {
       delete value;
+      emwgpuDelete(value);
     }
   }
 
@@ -641,7 +641,8 @@ struct WGPUAdapterImpl final : public EventSource, public RefCounted {
 struct WGPUBufferImpl final : public EventSource,
                               public RefCountedWithExternalCount {
  public:
-  WGPUBufferImpl(const EventSource* source, bool mappedAtCreation);
+  WGPUBufferImpl(const EventSource* source, bool mappedAtCreation, bool isExternal);
+  ~WGPUBufferImpl();
 
   void Destroy();
   const void* GetConstMappedRange(size_t offset, size_t size);
@@ -671,6 +672,7 @@ struct WGPUBufferImpl final : public EventSource,
   };
   MapRequest mPendingMapRequest;
   WGPUBufferMapState mMapState;
+  bool mIsExternal;
 };
 
 struct WGPUQueueImpl final : public EventSource, public RefCounted {
@@ -1164,11 +1166,15 @@ WGPUAdapter emwgpuCreateAdapter(const EventSource* source) {
 
 WGPUBuffer emwgpuCreateBuffer(const EventSource* source,
                               bool mappedAtCreation = false) {
-  return new WGPUBufferImpl(source, mappedAtCreation);
+  return new WGPUBufferImpl(source, mappedAtCreation, true);
 }
 
 WGPUDevice emwgpuCreateDevice(const EventSource* source, WGPUQueue queue) {
-  return new WGPUDeviceImpl(source, queue);
+  // This function is only called from JS via `importJsDevice()`, which
+  // needs to increment the external ref count to fix the behavior.
+  WGPUDeviceImpl* device = new WGPUDeviceImpl(source, queue);
+  device->AddExternalRef();
+  return device;
 }
 
 WGPUQueue emwgpuCreateQueue(const EventSource* source) {
@@ -1275,15 +1281,22 @@ WGPUAdapterImpl::WGPUAdapterImpl(const EventSource* source)
 // WGPUBuffer implementations.
 // ----------------------------------------------------------------------------
 
-WGPUBufferImpl::WGPUBufferImpl(const EventSource* source, bool mappedAtCreation)
+WGPUBufferImpl::WGPUBufferImpl(const EventSource* source, bool mappedAtCreation, bool isExternal)
     : EventSource(source),
       mMapState(mappedAtCreation ? WGPUBufferMapState_Mapped
-                                 : WGPUBufferMapState_Unmapped) {
+                                 : WGPUBufferMapState_Unmapped),
+      mIsExternal(isExternal) {
   if (mappedAtCreation) {
     mPendingMapRequest = {kNullFutureId, WGPUMapMode_Write};
   }
 }
 
+WGPUBufferImpl::~WGPUBufferImpl() {
+  if (!mIsExternal) {
+    Destroy();
+  }
+}
+
 void WGPUBufferImpl::Destroy() {
   emwgpuBufferDestroy(this);
   AbortPendingMap("Buffer was destroyed before mapping was resolved.");
@@ -1504,6 +1517,7 @@ WGPUFuture WGPUShaderModuleImpl::GetCompilationInfo(
   void wgpu##Name##Release(WGPU##Name o) {       \
     if (o->Release()) {                          \
       delete o;                                  \
+      emwgpuDelete(o);                           \
     }                                            \
   }
 WGPU_OBJECTS(DEFINE_WGPU_DEFAULT_ADDREF_RELEASE)
@@ -1638,7 +1652,7 @@ void wgpuBufferUnmap(WGPUBuffer buffer) {
 
 WGPUBuffer wgpuDeviceCreateBuffer(WGPUDevice device,
                                   const WGPUBufferDescriptor* descriptor) {
-  WGPUBuffer buffer = new WGPUBufferImpl(device, descriptor->mappedAtCreation);
+  WGPUBuffer buffer = new WGPUBufferImpl(device, descriptor->mappedAtCreation, false);
   emwgpuDeviceCreateBuffer(device, descriptor, buffer);
   return buffer;
 }
